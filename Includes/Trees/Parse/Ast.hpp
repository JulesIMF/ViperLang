/*++

Copyright (c) 2023 JulesIMF, MIPT

Module Name:

    Ast.hpp

Abstract:

    AST --- Abstract Syntax Tree. Parser uses it to represent
    the exact source code structure, but skipping useless details
    unlike CST --- Concrete Syntax Tree.

    Node types inheritance follows grammar structure.
    If there is a rule A -> B | C, than B and C will be
    (almost surely) inherited from A.

Author / Creation date:

    JulesIMF / 16.03.23

Revision History:

--*/

#pragma once

//
// Includes / usings
//

#include <Lex/Location.hpp>
#include <Lex/Token.hpp>
#include <Trees/BasicTree.hpp>
#include <cstddef>
#include <optional>
#include <string>
#include <variant>
#include <vector>
#include <Common/Assert.hpp>
#include <Trees/Parse/AstVisitor.hpp>

//
// Definitions
//

namespace Parse
{

//
// This code structure is generated by Source/Misc/asttypes.py
//

class AstNode : public BasicTree
{
public:
    AstNode(Lex::Location location) :
        location_(location)
    {
    }

    Lex::Location const& Location()
    {
        return location_;
    }

    template <typename T>
    T*
    As()
    {
        return dynamic_cast<T*>(this);
    }

    virtual ~AstNode() = default;

protected:
    Lex::Location location_;
};

template <typename T>
class AstList
{
public:
    inline bool
    Empty() const
    {
        return nodes_.empty();
    }

    inline size_t
    Size() const
    {
        return nodes_.size();
    }

    inline std::vector<T*>&
    Nodes()
    {
        return nodes_;
    }

protected:
    std::vector<T*> nodes_;
};

class File : public AstNode
{
public:
    File(Lex::Location location) :
        AstNode(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().File(this);
    }

    SuperStmtList* superStmtList = nullptr;
};

class SuperStmtList : public AstNode, public AstList<SuperStmt>
{
public:
    using SuperType = AstList<SuperStmt>;

    SuperStmtList(Lex::Location location) :
        AstNode(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().SuperStmtList(this);
    }
};

class SuperStmt : public AstNode
{
public:
    enum class Kind
    {
        None,
        FncDef,
        StmtList
    };

    SuperStmt(Lex::Location location) :
        AstNode(location)
    {
    }

    virtual Kind SuperStmtKind() = 0;
};

class StmtList : public SuperStmt, public AstList<Stmt>
{
public:
    using SuperType = AstList<Stmt>;

    StmtList(Lex::Location location) :
        SuperStmt(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().StmtList(this);
    }

    virtual SuperStmt::Kind
    SuperStmtKind()
    {
        return SuperStmt::Kind::StmtList;
    }
};

class StmtBlock : public StmtList
{
public:
    StmtBlock(Lex::Location location) :
        StmtList(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().StmtBlock(this);
    }
};

class FncDef : public SuperStmt
{
public:
    FncDef(Lex::Location location) :
        SuperStmt(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().FncDef(this);
    }

    virtual SuperStmt::Kind
    SuperStmtKind()
    {
        return SuperStmt::Kind::FncDef;
    }

    Lex::IdAttributes funcId;
    ArgDefList*       argDefList = nullptr;
    Type*             type       = nullptr;
    StmtBlock*        stmtBlock  = nullptr;
};

class Stmt : public AstNode
{
public:
    enum class Kind
    {
        None,
        Ret,
        Break,
        Continue,
        Call,
        VarDecl,
        Asgn,
        If,
        While,
        For
    };

    Stmt(Lex::Location location) :
        AstNode(location)
    {
    }

    virtual Kind
    StmtKind() = 0;
};

class StmtSemiColon : public Stmt
{
public:
    StmtSemiColon(Lex::Location location) :
        Stmt(location)
    {
    }
};

class StmtColon : public Stmt
{
public:
    StmtColon(Lex::Location location) :
        Stmt(location)
    {
    }
};

class Ret : public StmtSemiColon
{
public:
    Ret(Lex::Location location) :
        StmtSemiColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Ret(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::Ret;
    }

    Expr* expr = nullptr;
};

class Break : public StmtSemiColon
{
public:
    Break(Lex::Location location) :
        StmtSemiColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Break(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::Break;
    }
};

class Continue : public StmtSemiColon
{
public:
    Continue(Lex::Location location) :
        StmtSemiColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Continue(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::Continue;
    }
};

class CallStmt : public StmtSemiColon
{
public:
    CallStmt(Lex::Location location) :
        StmtSemiColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().CallStmt(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::Call;
    }

    Lex::IdAttributes funcId;
    ArgPassList*      argPassList = nullptr;
};

class ArgPassList : public AstNode, public AstList<Expr>
{
public:
    using SuperType = AstList<Expr>;

    ArgPassList(Lex::Location location) :
        AstNode(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().ArgPassList(this);
    }
};

class VarDecl : public StmtSemiColon
{
public:
    VarDecl(Lex::Location location) :
        StmtSemiColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().VarDecl(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::VarDecl;
    }

    Lex::IdAttributes varId;
    Type*             type = nullptr;
    Expr*             initExpr = nullptr;
};

class LValue
{
public:
    enum class Kind
    {
        None,
        Var
    };

    LValue() = default;

    Kind
    CurrentKind()
    {
        return kind_;
    }

    Var*
    AsVar()
    {
        return std::get<Var*>(lValue_);
    }

    Var*
    operator=(Var* var)
    {
        lValue_ = var;
        kind_ = Kind::Var;
        return var;
    }

    LValue(Var* var) :
        lValue_(var)
    {
    }

protected:
    std::variant<std::monostate, Var*> lValue_;
    Kind                               kind_ = Kind::None;
};

class Asgn : public StmtSemiColon
{
public:
    enum class Kind
    {
        None,
        Asgn,
        Add,
        Sub,
        Mul,
        Div,
        Rem,
        And,
        Or,
        Land,
        Lor,
    };

    static std::string
    KindToStr(Kind kind)
    {
        switch(kind)
        {
            case Kind::None:
                return "None";
            case Kind::Asgn:
                return "Asgn";
            case Kind::Add:
                return "Add";
            case Kind::Sub:
                return "Sub";
            case Kind::Mul:
                return "Mul";
            case Kind::Div:
                return "Div";
            case Kind::Rem:
                return "Rem";
            case Kind::And:
                return "And";
            case Kind::Or:
                return "Or";
            case Kind::Land:
                return "Land";
            case Kind::Lor:
                return "Lor";
            default:
                UnreachableMsg("Unknown kind");
        }
    }

    Asgn(Lex::Location location) :
        StmtSemiColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Asgn(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::Asgn;
    }

    LValue lValue;
    Kind   kind = Kind::None;
    Expr*  expr = nullptr;
};

class If : public StmtColon
{
public:
    struct IfBlock
    {
        Cond*      cond      = nullptr;
        StmtBlock* stmtBlock = nullptr;
    };

    If(Lex::Location location) :
        StmtColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().If(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::If;
    }

    IfBlock              ifBlock;
    std::vector<IfBlock> elifBlocks;
    StmtBlock*           elseBlock = nullptr;
};

class While : public StmtColon
{
public:
    While(Lex::Location location) :
        StmtColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().While(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::While;
    }

    Cond*      cond      = nullptr;
    StmtBlock* stmtBlock = nullptr;
};

class For : public StmtColon
{
public:
    For(Lex::Location location) :
        StmtColon(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().For(this);
    }

    virtual Stmt::Kind
    StmtKind()
    {
        return Stmt::Kind::For;
    }

    Expr*      expr      = nullptr;
    StmtBlock* stmtBlock = nullptr;
};

class ArgDefList : public AstNode, public AstList<VarDecl>
{
public:
    using SuperType = AstList<VarDecl>;
    
    ArgDefList(Lex::Location location) :
        AstNode(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().ArgDefList(this);
    }
};

class Type : public AstNode
{
public:
    Type(Lex::Location location) :
        AstNode(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Type(this);
    }

    Lex::IdAttributes typeId;
};

class BinaryOperation
{
public:
    enum class OpKind
    {
        None,
        Land,
        Lor,
        Lss,
        Gtr,
        Leq,
        Eql,
        Neq,
        Add,
        Sub,
        Or,
        Mul,
        Div,
        And,
    };

    static std::string
    KindToStr(OpKind kind)
    {
        switch (kind)
        {
            case OpKind::None:
                return "None";
            case OpKind::Land:
                return "Land";
            case OpKind::Lor:
                return "Lor";
            case OpKind::Lss:
                return "Lss";
            case OpKind::Gtr:
                return "Gtr";
            case OpKind::Leq:
                return "Leq";
            case OpKind::Eql:
                return "Eql";
            case OpKind::Neq:
                return "Neq";
            case OpKind::Add:
                return "Add";
            case OpKind::Sub:
                return "Sub";
            case OpKind::Or:
                return "Or";
            case OpKind::Mul:
                return "Mul";
            case OpKind::Div:
                return "Div";
            case OpKind::And:
                return "And";
            default:
                UnreachableMsg("Unknown kind");
        }
    }

    bool
    TwoOperands()
    {
        return operands.size() == 2 && operations.size() == 1;
    }

    Expr*
    Left()
    {
        if (TwoOperands())
            return operands[0];

        return nullptr;
    }

    Expr*
    Right()
    {
        if (TwoOperands())
            return operands[1];

        return nullptr;
    }

    OpKind
    Operation()
    {
        if (TwoOperands())
            return operations[0];
        
        return OpKind::None;
    }

    bool Correct()
    {
        return operands.size() == operations.size() + 1;
    }

    std::vector<Expr*>  operands;
    std::vector<OpKind> operations;
};

class Expr : public AstNode
{
public:
    enum class Kind
    {
        Expr,
        Logc,
        Comp,
        Form,
        Term,
        // Prim
        Unary,
        CallExpr,
        // Imm,
        Int,
        Float,
        Char,
        String,
        Var
    };

    virtual Kind
    ExprKind() = 0;

    Expr(Lex::Location location) :
        AstNode(location)
    {
    }
};

class Logc : public Expr, public BinaryOperation
{
public:
    Logc(Lex::Location location) :
        Expr(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Logc(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::Logc;
    }
};

class Comp : public Expr, public BinaryOperation
{
public:
    Comp(Lex::Location location) :
        Expr(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Comp(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::Comp;
    }
};

class Form : public Expr, public BinaryOperation
{
public:
    Form(Lex::Location location) :
        Expr(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Form(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::Form;
    }
};

class Term : public Expr, public BinaryOperation
{
public:
    Term(Lex::Location location) :
        Expr(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Term(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::Term;
    }
};

class Prim : public Expr
{
public:
    Prim(Lex::Location location) :
        Expr(location)
    {
    }
};

class Unary : public Prim
{
public:
    enum class UnaryKind
    {
        None,
        Not,
        Sub
    };

    static std::string
    KindToStr(UnaryKind kind)
    {
        switch (kind)
        {
            case UnaryKind::None:
                return "None";
            case UnaryKind::Not:
                return "Not";
            case UnaryKind::Sub:
                return "Sub";
            default:
                UnreachableMsg("Unknown kind");
        }
    }

    Unary(Lex::Location location) :
        Prim(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Unary(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::Unary;
    }

    UnaryKind kind = UnaryKind::None;
    Prim*     prim = nullptr;
};

class CallExpr : public Prim
{
public:
    CallExpr(Lex::Location location) :
        Prim(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().CallExpr(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::CallExpr;
    }

    Lex::IdAttributes funcId;
    ArgPassList*      argPassList = nullptr;
};

class Imm : public Prim
{
public:
    Imm(Lex::Location location) :
        Prim(location)
    {
    }
};

class Int : public Imm
{
public:
    Int(Lex::Location location) :
        Imm(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Int(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::Int;
    }

    Lex::IntAttributes intAttributes;
};

class Char : public Imm
{
public:
    Char(Lex::Location location) :
        Imm(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Char(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::Char;
    }

    Lex::CharAttributes charAttributes;
};

class String : public Imm
{
public:
    String(Lex::Location location) :
        Imm(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().String(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::String;
    }

    Lex::StringAttributes stringAttributes;
};

class Var : public Prim
{
public:
    Var(Lex::Location location) :
        Prim(location)
    {
    }

    virtual void
    Accept(Visitor& visitor)
    {
        visitor.As<AstVisitor>().Var(this);
    }

    virtual Expr::Kind
    ExprKind()
    {
        return Expr::Kind::Var;
    }

    Lex::IdAttributes varId;
};

};  // namespace Parse