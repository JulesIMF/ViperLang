
# 3. Recursive Descent Parser

В этом задании мы хотим научиться преобразовывать поток токенов в AST.

## Пререквизиты
  
1. Lexer
2. Ast

## Рекурсивный спуск

### Идея

Как бы мы хотели видеть нашу грамматику:

```
expression   ::= literal
               | unary
               | binary
               | ( <expression> )
               
unary        ::= ( "-" | "!" ) <expression>
binary       ::= <expression> <operator> <expression> ;
operator     ::= "==" | "!=" | "<" | "<=" | ">" | ">="
               | "+"  | "-"  | "*" | "/"
```

К сожалению, таком простом виде правила никак не учитывают **приоритет операций**. `1 + 2 * 3` — это `(1 + 2) * 3` или `1 + (2 * 3)` ? 

Таблица приоритетов операций ([полная версия](https://en.cppreference.com/w/c/language/operator_precedence)):
| Precedence |  Operator  |      Associativity      |
|-------------------------|-------------------------|-
|      1     | f() — call |           →             |
|      2     |    - !     |           ←             |
|      3     |    * /     |           →             |
|      4     |    + -     |           →             |
|      5     |    < <=    |           →             |
|            |    > >=    |                         |
|      6     |    == !=   |           →             |

Представьте себе бесконечный вправо корректный поток токенов в составе выражения.

В какой-то момент в этом потоке нам впервые встретится оператор с самым низким приоритетом: `==`. Это значит, что слева от него все операции имеют более выскоий приоритет. Значит их можно распарсить операцией: `ParseB` — которая работает теперь с грамматикой только из 5 правил.

```
        Parse(...   ==   ...  ==  ...  ==  ... )
      --------------------------------------------
                    ==
       ParseB(...)   |
                     |
                   Parse(...  ==  ...  ==  ...)
```

`ParseB` будет работать абсолютно аналагично:

```
       ParseB(...   <=  ...  >=  ... )
      ----------------------------------
                    <=
       ParseC(...)   |
                     |
                   ParseB(...  >=  ...)
```

Построим отображение из 

| Fake Name | Real Name    |
| --------- | -----------  |
| Parse  | ParseExpression |
| ParseB | ParseRelational |
| ParseC | ParseAdditive   |
| ParseD | ParseMult       |
| ParseE | ParseUnary      |
| ParseF | ParsePostfix    |
| ParseG | ParsePrimary    |

Однако здесь есть проблема — ассоциативность. Рассмотрим пример `1 - 2 - 3`
```
       1 - 2 - 3                                   1 - 2 - 3
      -----------                             ------------------
         -                      !=                       -
      1                                                    3 
           2 - 3                                   1 - 2

```


В грамматике языка мы можем решить её слудующим правилом, которое удостоверивается, что мы каждый раз отъедаем последний оператор.

```
<additive-expression> ::= <multiplicative-expression>
                        | <additive-expression> - <multiplicative-expression>
```

Но что делать в реализации? Ведь мы не можем реализовать `ParseAdditive` c помощью прямого вызова `ParseAdditive` на потоке символов.


#### Левая рекурсия

Правила такого вида называются леворекурсивными. Они решаются ~~дедовским способом~~ превращением рекурсии в итерацию. 

```
<additive-expression> ::= <multiplicative-expression> ( - <multiplicative-expression> )* ;
```

Заметим, что здесь мы снова потеряли ассоциативность в грамматике

### Railroad diagrams

![./media/4-railroad.png]()

## Задание

1. Прочитайте [Crafting Interpreters: Parsing Expressions](https://craftinginterpreters.com/parsing-expressions.html)
2. Создайте класс `Parser`, обрабатывающий все конструкции нашей грамматики
3. Воспользуйтесь `PrintVisitor` из прошлого задания, чтобы отобразить полученные результаты
4. Создайте класс-**калькулятор арифметических выражений**
   - В первом приближении в качестве *таблицы символов* используйте `std::unordered_map`
   - Динамически обрабатывайте случаи `1 + true` или `if "abc" then 123`, `if true then 123 else true`

## Реализация


